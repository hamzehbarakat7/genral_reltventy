<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Ù…Ø­Ø§ÙƒÙŠ Ø§Ù„Ø²Ù…ÙƒØ§Ù† 3D â€” Ù†Ø³Ø®Ø© Ø£Ø¯Ù‚</title>
<style>
:root{ --bg:#0b0f16; --panel:#0f1624; --accent:#59c1ff; --muted:#9fb3c8; --good:#7ee787; --warn:#ffd166; --bad:#ff6b6b; --grid:#1f2a3d; --text:#e6edf3; --header:#0c1420; }
:root.light{ --bg:#f7f9fc; --panel:#ffffff; --accent:#0066ff; --muted:#5a6b7e; --good:#1f8f3a; --warn:#a36b00; --bad:#c03d3d; --grid:#e6eef6; --text:#0f172a; --header:#ffffff; }
*{box-sizing:border-box}
html,body{height:100%;margin:0;overflow:hidden}
body{background:var(--bg);color:var(--text);font:14px/1.5 system-ui,Segoe UI,Roboto,Arial}
header{display:flex;align-items:center;gap:12px;padding:10px 14px;background:var(--header);border-bottom:1px solid #152033;z-index:5}
header h1{font-size:16px;margin:0;color:#cfe3ff}
:root.light header h1{color:#003366}
header .badge{padding:3px 8px;border:1px solid #22324a;border-radius:9999px;color:#c2d4ee;font-size:12px}
header .legend{margin-inline-start:auto;display:flex;gap:8px;flex-wrap:wrap}
.wrap{display:flex;flex-direction:column;height:calc(100vh - 44px)}
.main-content{flex:1;position:relative;overflow:hidden;background:radial-gradient(1400px 900px at 50% 40%, #0f1a2a 0, var(--bg) 70%)}
:root.light .main-content{background:radial-gradient(1400px 900px at 50% 40%, #e6f0ff 0, var(--bg) 70%)}
aside{background:var(--panel);border-top:1px solid #152033;padding:12px;display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:10px;max-height:35vh;overflow-y:auto}
.group{border:1px solid #1f2a3d;border-radius:10px;padding:10px;background:color-mix(in srgb, var(--panel) 94%, #000 6%)}
.group h3{margin:0 0 8px 0;font-size:13px;color:#cfe3ff}
:root.light .group h3{color:#003366}
.group h4{margin:0 0 6px 0;font-size:12px;color:#b9d3ff}
label{display:grid;grid-template-columns: 1fr auto; gap:6px; align-items:center;margin:5px 0;font-size:12px}
input[type="number"], input[type="text"], select{width:140px;background:#0c1320;color:#e6edf3;border:1px solid #1f2a3d;border-radius:6px;padding:5px;font-size:12px}
:root.light input[type="number"], :root.light input[type="text"], :root.light select{background:#f1f5fb;color:#0f172a;border-color:#cbd5e1}
input[type="checkbox"]{transform:scale(1.1)}
input[type="range"]{width:100%}
button{background:#122035;border:1px solid #283a57;color:#e6f2ff;border-radius:8px;padding:6px 10px;cursor:pointer;font-size:12px}
button:hover{border-color:#3c577f;background:#1a2a45}
:root.light button{background:#e6f0ff;border-color:#bfd4ff;color:#003366}
.row{display:flex;gap:8px;flex-wrap:wrap} .row > *{flex:1}
.pill{padding:4px 8px;border-radius:9999px;border:1px solid #22324a;color:#c9ddff;font-size:11px}
#view{display:block;width:100%;height:100%}
.hud{position:absolute;left:10px;top:10px;background:rgba(15,22,36,.85);border:1px solid #1f2a3d;border-radius:10px;padding:10px;backdrop-filter:blur(6px);min-width:260px;max-width:320px}
:root.light .hud{background:rgba(255,255,255,.85);border-color:#cbd5e1}
.grid{display:grid;grid-template-columns:auto 1fr;gap:4px 10px;align-items:center;font-size:11px}
.cards{display:grid;gap:8px;grid-template-columns:repeat(auto-fit,minmax(180px,1fr))}
.card{background:#0e1626;border:1px solid #1f2a3d;border-radius:8px;padding:8px;font-size:11px}
:root.light .card{background:#ffffff;border-color:#e2e8f0}
.card h4{margin:0 0 6px 0;font-size:12px;color:#cfe3ff;display:flex;justify-content:space-between;align-items:center}
:root.light .card h4{color:#003366}
.card .meta{display:grid;grid-template-columns:auto 1fr;gap:3px 8px;color:#9fb3c8}
:root.light .card .meta{color:#334155}
.card .rowBtns{display:flex;gap:4px;margin-top:6px}
.card button{padding:4px 8px;font-size:10px}
.badgeSmall{padding:2px 5px;border:1px solid #28405e;border-radius:999px;color:#9fd1ff;font-size:10px}
.selected{outline:2px solid var(--accent)}
#chart{display:block;margin-top:8px;width:100%;height:90px}
.toggleTheme{margin-inline-start:8px}
</style>
</head>
<body>
<header>
  <h1>Ù…Ø­Ø§ÙƒÙŠ Ø§Ù„Ø²Ù…ÙƒØ§Ù† 3D</h1>
  <span class="badge">RK4 ØªÙƒÙŠÙÙŠ + 1PN (Ù†Ø³Ø¨ÙŠ) + 3D</span>
  <div class="legend">
    <span class="pill">Ø¥Ø³Ù‚Ø§Ø· 3D</span>
    <span class="pill">Ù…Ø³Ø§Ø±Ø§Øª</span>
  </div>
  <button id="btnTheme" class="toggleTheme">ğŸŒ™ Night / â˜€ï¸ Day</button>
</header>

<div class="wrap">
  <div class="main-content">
    <canvas id="view"></canvas>
    <div class="hud">
      <h4>Ù„ÙˆØ­Ø© ÙÙŠØ²ÙŠØ§Ø¦ÙŠØ©</h4>
      <div class="grid" id="stats"></div>
      <canvas id="chart"></canvas>
    </div>
  </div>

  <aside>
    <div class="group">
      <h3>Ø§Ù„ØªØ­ÙƒÙ…</h3>
      <div class="row">
        <button id="btnPlay">â–¶ ØªØ´ØºÙŠÙ„</button>
        <button id="btnStep">â­ Ø®Ø·ÙˆØ©</button>
        <button id="btnReset">âŸ² Ø¥Ø¹Ø§Ø¯Ø©</button>
      </div>
      <label>Ø§Ù„Ø³Ø±Ø¹Ø© <input type="number" id="speedMul" step="0.5" value="1" style="width:80px" /></label>
      <label>Î”t (Ø«) <input type="number" id="dt" step="0.1" value="1" style="width:80px" /></label>
      <label><input type="checkbox" id="adaptive" checked /> ØªÙƒÙŠÙÙŠ</label>
      <label><input type="checkbox" id="enablePN" /> 1PN</label>
      <label>Ø§Ù„ØªØµØ§Ø¯Ù…
        <select id="collisionMode" style="width:100px">
          <option value="none">Ø¨Ø¯ÙˆÙ†</option>
          <option value="merge">Ø¯Ù…Ø¬</option>
        </select>
      </label>
      <div class="row" style="margin-top:6px">
        <button id="btnWarmup">ğŸ”¥ ØªØ³Ø®ÙŠÙ† (200)</button>
      </div>
    </div>

    <div class="group">
      <h4>ÙƒØ§Ù…ÙŠØ±Ø§ 3D</h4>
      <label>ØªÙƒØ¨ÙŠØ± <input id="zoomRange" type="range" min="-200" max="200" step="2" value="0" /></label>
      <label>Ø¯ÙˆØ±Ø§Ù† Ø£ÙÙ‚ÙŠ <input id="rotY" type="range" min="0" max="360" step="2" value="45" /></label>
      <label>Ø¯ÙˆØ±Ø§Ù† Ø¹Ù…ÙˆØ¯ÙŠ <input id="rotX" type="range" min="-90" max="90" step="2" value="30" /></label>
      <small class="muted" id="zoomLabel">â€”</small>
    </div>

    <div class="group">
      <h3>Ù…Ø´Ø§Ù‡Ø¯ Ø¬Ø§Ù‡Ø²Ø©</h3>
      <select id="preset" style="width:100%">
        <option value="solar">Ù†Ø¸Ø§Ù… Ø´Ù…Ø³ÙŠ</option>
        <option value="binary">Ù†Ø¬Ù…Ø§Ù† Ø«Ù†Ø§Ø¦ÙŠØ§Ù†</option>
        <option value="three">Ù…Ø´ÙƒÙ„Ø© Ø§Ù„Ø«Ù„Ø§Ø«Ø©</option>
        <option value="bhStar">Ø«Ù‚Ø¨ Ø£Ø³ÙˆØ¯</option>
        <option value="random">Ø¹Ø´ÙˆØ§Ø¦ÙŠ</option>
      </select>
      <button id="btnLoadPreset" style="width:100%;margin-top:6px">ØªØ­Ù…ÙŠÙ„</button>
    </div>

    <div class="group">
      <h3>Ø¥Ø¶Ø§ÙØ© Ø¬Ø±Ù…</h3>
      <label>Ø§Ø³Ù… <input id="bName" value="Body" style="width:100px"/></label>
      <label>ÙƒØªÙ„Ø© <input id="bMass" type="number" value="5.972e24" style="width:100px"/></label>
      <label>x <input id="bX" type="number" value="1.5e11" style="width:100px"/></label>
      <label>y <input id="bY" type="number" value="0" style="width:100px"/></label>
      <label>z <input id="bZ" type="number" value="0" style="width:100px"/></label>
      <label>vx <input id="bVX" type="number" value="0" style="width:100px"/></label>
      <label>vy <input id="bVY" type="number" value="29780" style="width:100px"/></label>
      <label>vz <input id="bVZ" type="number" value="0" style="width:100px"/></label>
      <div class="row" style="margin-top:6px">
        <button id="btnAdd">â• Ø¥Ø¶Ø§ÙØ©</button>
        <button id="btnClear">ğŸ—‘ï¸ Ø­Ø°Ù Ø§Ù„ÙƒÙ„</button>
      </div>
    </div>

    <div class="group">
      <h3>Ø®ÙŠØ§Ø±Ø§Øª</h3>
      <label><input type="checkbox" id="showTrails" checked /> Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª</label>
      <label><input type="checkbox" id="showGrid" checked /> Ø§Ù„Ø´Ø¨ÙƒØ©</label>
      <label>ØªØªØ¨Ø¹ <select id="track" style="width:100px"></select></label>
      <button id="btnTrackRecalc" style="width:100%;margin-top:4px">ğŸ¯ ØªØªØ¨Ø¹ + Ø¥Ø¹Ø§Ø¯Ø© Ø­Ø³Ø§Ø¨ 40Ø«</button>
      <label>ÙˆØ¶Ø¹ Ø§Ù„ØªØªØ¨Ø¹
  <select id="trackMode" style="width:120px">
    <option value="free">Ø­Ø±</option>
    <option value="body">Ø¬Ø³Ù…</option>
    <option value="group">Ù…Ø¬Ù…ÙˆØ¹Ø©</option>
    <option value="cm">Ø§Ù„Ù…Ø±Ø¬Ø­ (CM)</option>
  </select>
</label>
<small style="opacity:.8">ÙÙŠ ÙˆØ¶Ø¹ â€œÙ…Ø¬Ù…ÙˆØ¹Ø©â€ Ø§Ø®ØªØ± Ø§Ù„Ø£Ø¬Ø³Ø§Ù… Ù…Ù† Ø¨Ø·Ø§Ù‚Ø§ØªÙ‡Ø§ (Ø²Ø± ğŸ¯)</small>

      <button id="btnCSV" style="width:100%;margin-top:4px">ğŸ’¾ Ø­ÙØ¸ CSV</button>
      <label><input type="checkbox" id="autoReorbit" checked /> Ø¥Ø¹Ø§Ø¯Ø© Ø­Ø³Ø§Ø¨ ÙƒÙ„ 30Ø«</label>
      <button id="btnReorbit" style="width:100%">â†» Ø¥Ø¹Ø§Ø¯Ø© Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¢Ù†</button>
      <label><input type="checkbox" id="anchorHeavy" checked /> ØªØ«Ø¨ÙŠØª Ø§Ù„Ø£Ø«Ù‚Ù„ ÙƒÙ…Ø±Ø¬Ø¹</label>
      <button id="btnBary" style="width:100%;margin-top:4px">â†” Ø¥Ø·Ø§Ø± Ø¨Ø§Ø±ÙŠ-Ù…Ø±ÙƒØ²ÙŠ (Ø·Ø±Ø­ CM)</button>
      <button id="btnAnchorHeavy" style="width:100%;margin-top:4px">ğŸ¯ ØªØ«Ø¨ÙŠØª Ø§Ù„Ø£ØµÙ„ Ø¹Ù†Ø¯ Ø§Ù„Ø£Ø«Ù‚Ù„</button>
      <button id="btnRetune" style="width:100%;margin-top:4px">âš™ï¸ Ø³Ø±Ø¹Ø§Øª Ø¯Ø§Ø¦Ø±ÙŠØ© Ø­ÙˆÙ„ Ø§Ù„Ø£Ø«Ù‚Ù„</button>

    </div>

    <div class="group">
      <h3>Ø¨Ø·Ø§Ù‚Ø§Øª Ø§Ù„Ø£Ø¬Ø³Ø§Ù…</h3>
      <div id="bodyCards" class="cards"></div>
    </div>
  </aside>
</div>

<script>
/* ====== Ø«ÙˆØ§Ø¨Øª ÙˆØ­Ø§Ù„Ø© Ø¹Ø§Ù…Ø© ====== */
const C = 299792458, G = 6.67430e-11, SOFT = 1e6;
let bodies = [], time = 0, running = false, currentDt = 0;
const state = {
  dt: 1, minDt: 1e-4, maxDt: 20,
  adaptive: true, pn: false, speedMul: 1,
  collision: 'merge', trails: true, showGrid: true,
  relTol: 1e-4, absTol: 1e-1
};
// ØªØªØ¨Ø¹/ÙƒØ§Ù…ÙŠØ±Ø§
const trackState = {
  mode: 'free',           // 'free' | 'body' | 'group' | 'cm'
  bodyIndex: -1,          // ÙŠØ³ØªØ®Ø¯Ù… Ù…Ø¹ mode='body'
  group: new Set(),       // Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„Ø£Ø¬Ø³Ø§Ù… Ø§Ù„Ù…Ø®ØªØ§Ø±Ø©
};

const view = document.getElementById('view');
const ctx = view.getContext('2d', { alpha: false });
const hudStats = document.getElementById('stats');
const chart = document.getElementById('chart');
const cctx = chart.getContext('2d');
const cardsRoot = document.getElementById('bodyCards');
const q = id => document.getElementById(id);

/* ====== ØªÙ‡ÙŠØ¦Ø© ÙˆØ§Ø¬Ù‡Ø© ====== */
if (q('collisionMode')) q('collisionMode').value = 'merge';

/* ÙˆØ¶Ø¹ Ù„ÙŠÙ„ÙŠ/Ù†Ù‡Ø§Ø±ÙŠ */
q('btnTheme').onclick = () => {
  const root = document.documentElement;
  root.classList.toggle('light');
};

/* ÙƒØ§Ù…ÙŠØ±Ø§ */
let cam = { dist: 5e11, rotX: 30 * Math.PI / 180, rotY: 45 * Math.PI / 180, scale: 1 };
function resize() {
  if (!view || !chart) return;
  const pr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  view.width = Math.floor(view.clientWidth * pr);
  view.height = Math.floor(view.clientHeight * pr);
  chart.width = Math.floor(chart.clientWidth * pr);
  chart.height = Math.floor(90 * pr);
  ctx.setTransform(pr,0,0,pr,0,0); // Ù„ØªÙØ§Ø¯ÙŠ Ø¶Ø¨Ø§Ø¨ÙŠØ© Ø§Ù„Ø±Ø³Ù…
  cctx.setTransform(pr,0,0,pr,0,0);
}
window.addEventListener('resize', resize);

function updateCamera() {
  if (!q('zoomRange') || !q('rotX') || !q('rotY')) return;
  const zr = parseFloat(q('zoomRange').value || 0);
  cam.dist = 2e11 * Math.exp(zr * 0.0115);
  cam.rotX = parseFloat(q('rotX').value || 30) * Math.PI / 180;
  cam.rotY = parseFloat(q('rotY').value || 45) * Math.PI / 180;
  cam.scale = view.width / Math.max(1, (cam.dist * 0.8));
  const label = document.getElementById('zoomLabel');
  if (label && isFinite(cam.dist)) label.textContent = `Ø§Ù„Ù…Ø³Ø§ÙØ©: ${(cam.dist / 1e9).toFixed(1)} Gm`;
}
if (q('zoomRange')) q('zoomRange').oninput = updateCamera;
if (q('rotX')) q('rotX').oninput = updateCamera;
if (q('rotY')) q('rotY').oninput = updateCamera;

/* Ø¥Ø³Ù‚Ø§Ø· Ù…Ù†Ø¸ÙˆØ± Ù…Ø¨Ø³Ø· */
function project(x, y, z) {
  const cx = Math.cos(cam.rotY), sx = Math.sin(cam.rotY);
  const cy = Math.cos(cam.rotX), sy = Math.sin(cam.rotX);
  const x1 = x * cx - y * sx, y1 = x * sx + y * cx, z1 = z;
  const y2 = y1 * cy - z1 * sy, z2 = y1 * sy + z1 * cy + cam.dist;
  if (!isFinite(x1) || !isFinite(y2) || !isFinite(z2) || z2 <= 0) return null;
  const scale = cam.scale * (cam.dist / z2);
  if (!isFinite(scale)) return null;
  const X = (view.width / 2) + x1 * scale, Y = (view.height / 2) - y2 * scale;
  return (isFinite(X) && isFinite(Y)) ? [X, Y, z2, scale] : null;
}

/* Ø³Ø­Ø¨ ÙˆØªØ¯ÙˆÙŠØ±/ØªÙƒØ¨ÙŠØ± */
let dragging = false, lastX = 0, lastY = 0;
if (view) {
  view.addEventListener('mousedown', e => { dragging = true; lastX = e.clientX; lastY = e.clientY; });
  window.addEventListener('mouseup', () => dragging = false);
  window.addEventListener('mousemove', e => {
    if (!dragging) return;
    q('rotY').value = (+q('rotY').value || 0) + (e.clientX - lastX) * 0.5;
    q('rotX').value = (+q('rotX').value || 0) - (e.clientY - lastY) * 0.5;
    lastX = e.clientX; lastY = e.clientY; updateCamera();
  });
  view.addEventListener('wheel', e => {
    q('zoomRange').value = (+q('zoomRange').value || 0) - e.deltaY * 0.1;
    updateCamera();
  }, { passive: true });
}

/* Ø£Ø¯ÙˆØ§Øª Ø±ÙŠØ§Ø¶ÙŠØ© */
const v2 = (x, y, z) => x*x + y*y + z*z;
const mag = (x, y, z) => Math.sqrt(x*x + y*y + z*z);
const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
const palette = ["#58a6ff", "#ff7b72", "#8ddb8c", "#f2cc60", "#c39df3", "#76e4f7", "#f78fb3", "#a8d1ff"];
const randColor = () => palette[(Math.random()*palette.length)|0];

/* ====== ÙÙŠØ²ÙŠØ§Ø¡ ====== */
function computeAccelerations(usePN) {
  const n = bodies.length;
  const ax = new Float64Array(n), ay = new Float64Array(n), az = new Float64Array(n);
  for (let i = 0; i < n; i++) {
    const bi = bodies[i];
    for (let j = i + 1; j < n; j++) {
      const bj = bodies[j];
      const dx = bj.x - bi.x, dy = bj.y - bi.y, dz = bj.z - bi.z;
      const r2 = dx*dx + dy*dy + dz*dz + SOFT*SOFT;
      const r = Math.sqrt(r2), invr3 = 1.0 / (r2 * r);
      const f = G * bi.mass * bj.mass * invr3;
      const fx = f * dx, fy = f * dy, fz = f * dz;
      ax[i] += fx / bi.mass; ay[i] += fy / bi.mass; az[i] += fz / bi.mass;
      ax[j] -= fx / bj.mass; ay[j] -= fy / bj.mass; az[j] -= fz / bj.mass;
    }
  }
  if (usePN && n >= 2) {
    let ci = 0; for (let k = 1; k < n; k++) if (bodies[k].mass > bodies[ci].mass) ci = k;
    const Cb = bodies[ci];
    for (let i = 0; i < n; i++) {
      if (i === ci) continue;
      const b = bodies[i];
      const rx = b.x - Cb.x, ry = b.y - Cb.y, rz = b.z - Cb.z;
      const vx = b.vx - Cb.vx, vy = b.vy - Cb.vy, vz = b.vz - Cb.vz;
      const r = Math.max(1e-9, Math.sqrt(rx*rx + ry*ry + rz*rz));
      const rhatx = rx / r, rhaty = ry / r, rhatz = rz / r;
      const v2rel = vx*vx + vy*vy + vz*vz;
      const vr = vx*rhatx + vy*rhaty + vz*rhatz;
      const GM = G * Cb.mass, coef = -GM / (r*r);
      const termR = (4 * GM) / (r * C * C) - (v2rel / (C * C));
      ax[i] += coef * (termR * rhatx + (4 * vr / (C * C)) * vx);
      ay[i] += coef * (termR * rhaty + (4 * vr / (C * C)) * vy);
      az[i] += coef * (termR * rhatz + (4 * vr / (C * C)) * vz);
    }
  }
  return { ax, ay, az };
}

function rk4Step(dt, usePN) {
  const n = bodies.length;
  const x0 = new Float64Array(n), y0 = new Float64Array(n), z0 = new Float64Array(n);
  const vx0 = new Float64Array(n), vy0 = new Float64Array(n), vz0 = new Float64Array(n);
  for (let i = 0; i < n; i++) {
    const b = bodies[i];
    x0[i]=b.x; y0[i]=b.y; z0[i]=b.z; vx0[i]=b.vx; vy0[i]=b.vy; vz0[i]=b.vz;
  }
  let { ax: ax1, ay: ay1, az: az1 } = computeAccelerations(usePN);
  const k1x = vx0.slice(0), k1y = vy0.slice(0), k1z = vz0.slice(0);
  const k1vx = ax1.slice(0), k1vy = ay1.slice(0), k1vz = az1.slice(0);

  for (let i=0;i<n;i++){ bodies[i].x=x0[i]+0.5*dt*k1x[i]; bodies[i].y=y0[i]+0.5*dt*k1y[i]; bodies[i].z=z0[i]+0.5*dt*k1z[i];
    bodies[i].vx=vx0[i]+0.5*dt*k1vx[i]; bodies[i].vy=vy0[i]+0.5*dt*k1vy[i]; bodies[i].vz=vz0[i]+0.5*dt*k1vz[i]; }
  let { ax: ax2, ay: ay2, az: az2 } = computeAccelerations(usePN);
  const k2x = bodies.map(b=>b.vx), k2y = bodies.map(b=>b.vy), k2z = bodies.map(b=>b.vz);
  const k2vx = ax2.slice(0), k2vy = ay2.slice(0), k2vz = az2.slice(0);

  for (let i=0;i<n;i++){ bodies[i].x=x0[i]+0.5*dt*k2x[i]; bodies[i].y=y0[i]+0.5*dt*k2y[i]; bodies[i].z=z0[i]+0.5*dt*k2z[i];
    bodies[i].vx=vx0[i]+0.5*dt*k2vx[i]; bodies[i].vy=vy0[i]+0.5*dt*k2vy[i]; bodies[i].vz=vz0[i]+0.5*dt*k2vz[i]; }
  let { ax: ax3, ay: ay3, az: az3 } = computeAccelerations(usePN);
  const k3x = bodies.map(b=>b.vx), k3y = bodies.map(b=>b.vy), k3z = bodies.map(b=>b.vz);
  const k3vx = ax3.slice(0), k3vy = ay3.slice(0), k3vz = az3.slice(0);

  for (let i=0;i<n;i++){ bodies[i].x=x0[i]+dt*k3x[i]; bodies[i].y=y0[i]+dt*k3y[i]; bodies[i].z=z0[i]+dt*k3z[i];
    bodies[i].vx=vx0[i]+dt*k3vx[i]; bodies[i].vy=vy0[i]+dt*k3vy[i]; bodies[i].vz=vz0[i]+dt*k3vz[i]; }
  let { ax: ax4, ay: ay4, az: az4 } = computeAccelerations(usePN);
  const k4x = bodies.map(b=>b.vx), k4y = bodies.map(b=>b.vy), k4z = bodies.map(b=>b.vz);
  const k4vx = ax4.slice(0), k4vy = ay4.slice(0), k4vz = az4.slice(0);

  for (let i=0;i<n;i++){
    bodies[i].x = x0[i] + dt * (k1x[i] + 2*k2x[i] + 2*k3x[i] + k4x[i]) / 6;
    bodies[i].y = y0[i] + dt * (k1y[i] + 2*k2y[i] + 2*k3y[i] + k4y[i]) / 6;
    bodies[i].z = z0[i] + dt * (k1z[i] + 2*k2z[i] + 2*k3z[i] + k4z[i]) / 6;
    bodies[i].vx= vx0[i] + dt * (k1vx[i]+ 2*k2vx[i]+ 2*k3vx[i]+ k4vx[i]) / 6;
    bodies[i].vy= vy0[i] + dt * (k1vy[i]+ 2*k2vy[i]+ 2*k3vy[i]+ k4vy[i]) / 6;
    bodies[i].vz= vz0[i] + dt * (k1vz[i]+ 2*k2vz[i]+ 2*k3vz[i]+ k4vz[i]) / 6;
  }
}

/* ØªÙƒÙŠÙ Ø²Ù…Ù†ÙŠ */
function tryAdvance(dt, usePN) {
  const saved = bodies.map(b => ({ x:b.x,y:b.y,z:b.z,vx:b.vx,vy:b.vy,vz:b.vz }));
  rk4Step(dt, usePN);
  const oneStep = bodies.map(b => ({ x:b.x,y:b.y,z:b.z }));
  for (let i=0;i<bodies.length;i++) Object.assign(bodies[i], saved[i]);
  rk4Step(dt/2, usePN); rk4Step(dt/2, usePN);
  const twoHalf = bodies.map(b => ({ x:b.x,y:b.y,z:b.z }));
  let maxErr = 0;
  for (let i=0;i<bodies.length;i++){
    const a=oneStep[i], b=twoHalf[i];
    const ex=Math.abs(a.x-b.x), ey=Math.abs(a.y-b.y), ez=Math.abs(a.z-b.z);
    const scale = state.absTol + Math.max(Math.abs(a.x),Math.abs(b.x)) * state.relTol;
    maxErr = Math.max(maxErr, ex/scale, ey/scale, ez/scale);
  }
  if (maxErr > 1) {
    for (let i=0;i<bodies.length;i++) Object.assign(bodies[i], saved[i]);
    return { accepted:false, suggested: clamp(dt * Math.max(0.2, 0.9/Math.pow(maxErr,0.25)), state.minDt, state.maxDt) };
  }
  return { accepted:true, suggested: clamp(dt * Math.min(2.0, 0.9/Math.pow(maxErr+1e-12,0.2)), state.minDt, state.maxDt) };
}
function integrateAdaptive(baseDt) {
  let dt = baseDt * state.speedMul;
  if (!state.adaptive) { rk4Step(dt, state.pn); time += dt; currentDt = dt; return dt; }
  let ok=false, trial=dt, newDt=dt, guard=0;
  while (!ok && guard < 8) {
    const r = tryAdvance(trial, state.pn);
    if (r.accepted){ ok=true; newDt=r.suggested; } else { trial=r.suggested; }
    guard++;
  }
  time += trial; currentDt = trial;
  state.dt = clamp(newDt, state.minDt, state.maxDt);
  if (q('dt')) q('dt').value = state.dt;
  return trial;
}

/* ØªØµØ§Ø¯Ù…Ø§Øª Ø¯Ù…Ø¬ÙŠØ© */
function handleCollisions() {
  if (state.collision !== 'merge') return;
  const removed = [];
  for (let i=0;i<bodies.length;i++){
    for (let j=i+1;j<bodies.length;j++){
      const bi=bodies[i], bj=bodies[j];
      const r = mag(bj.x-bi.x, bj.y-bi.y, bj.z-bi.z);
      const Rsum = (Number(bi.radius)||0) + (Number(bj.radius)||0);
      if (r <= Math.max(1, Rsum)) {
        const M = bi.mass + bj.mass;
        bi.vx = (bi.vx*bi.mass + bj.vx*bj.mass) / M;
        bi.vy = (bi.vy*bi.mass + bj.vy*bj.mass) / M;
        bi.vz = (bi.vz*bi.mass + bj.vz*bj.mass) / M;
        bi.x  = (bi.x *bi.mass + bj.x *bj.mass) / M;
        bi.y  = (bi.y *bi.mass + bj.y *bj.mass) / M;
        bi.z  = (bi.z *bi.mass + bj.z *bj.mass) / M;
        bi.mass = M;
        const r1 = Math.max(1, Number(bi.radius)||1), r2 = Math.max(1, Number(bj.radius)||1);
        bi.radius = Math.cbrt(r1**3 + r2**3);
        bi.name = bi.name + "+" + bj.name;
        removed.push(j);
      }
    }
  }
  removed.sort((a,b)=>b-a).forEach(idx=>bodies.splice(idx,1));
  if (removed.length) refreshTrackList();
}

/* Ø·Ø§Ù‚Ø© ÙˆØ²Ø®Ù… */
function energyAndAngMom() {
  let KE=0, PE=0, Lz=0;
  for (const b of bodies) KE += 0.5 * b.mass * v2(b.vx,b.vy,b.vz);
  for (let i=0;i<bodies.length;i++){
    for (let j=i+1;j<bodies.length;j++){
      const r = mag(bodies[j].x-bodies[i].x, bodies[j].y-bodies[i].y, bodies[j].z-bodies[i].z) + SOFT;
      PE += -G * bodies[i].mass * bodies[j].mass / r;
    }
  }
  for (const b of bodies) Lz += b.mass * (b.x * b.vy - b.y * b.vx);
  return { E:KE+PE, KE, PE, Lz };
}

/* Ù…Ø¯Ø§Ø± Ù†Ø³Ø¨ÙŠ Ù…Ø¨Ø³Ù‘Ø· + ØªÙ‚Ø¯Ù‘Ù… Ø­Ø¶ÙŠØ¶ */
function computeRelativisticOrbitForBody(bodyIndex) {
  if (bodies.length < 2) return;
  let ci = 0; for (let k = 1; k < bodies.length; k++) if (bodies[k].mass > bodies[ci].mass) ci = k;
  if (bodyIndex === ci) return;

  const b = bodies[bodyIndex], Cb = bodies[ci];
  const rx = b.x - Cb.x, ry = b.y - Cb.y, rz = b.z - Cb.z;
  const vx = b.vx - Cb.vx, vy = b.vy - Cb.vy, vz = b.vz - Cb.vz;
  const r = mag(rx,ry,rz);
  const speed2 = v2(vx,vy,vz);            // <-- Ø¥ØµÙ„Ø§Ø­ ØªØ¹Ø§Ø±Ø¶ Ø§Ù„Ø§Ø³Ù…
  const mu = G * (Cb.mass + b.mass);

  const hx = ry*vz - rz*vy, hy = rz*vx - rx*vz, hz = rx*vy - ry*vx;
  const h2 = hx*hx + hy*hy + hz*hz;
  const E = speed2/2 - mu/r;

  let a = 0;
  if (E < 0) a = -mu/(2*E);
  else if (Math.abs(E) < 1e-12) a = Infinity;
  else a = mu/(2*E);

  let e;
  if (E < 0) e = Math.sqrt(Math.max(0, 1 + 2*E*h2/(mu*mu)));
  else if (Math.abs(E) < 1e-12) e = 1;
  else e = Math.sqrt(Math.max(0, 1 + 2*E*h2/(mu*mu)));

  let deltaPhiRad = 0;
  if (E < 0 && e < 1 && isFinite(a)) {
    const GM = G * Cb.mass;
    const one_minus_e2 = Math.max(1e-12, 1 - e*e);
    const p = a * one_minus_e2;
    deltaPhiRad = (6 * Math.PI * GM) / (C*C * p);
    const P = 2 * Math.PI * Math.sqrt(a*a*a / mu);
    const secPerCentury = 100 * 365.25 * 24 * 3600;
    const arcsecPerRad = 180 / Math.PI * 3600;
    const precessionArcsecPerCentury = (deltaPhiRad / P) * secPerCentury * arcsecPerRad;
    b.precession = isFinite(precessionArcsecPerCentury) ? precessionArcsecPerCentury : 0;
  } else {
    b.precession = 0;
  }
  b.a = a; b.e = e; b.centerBody = Cb.name;
}

/* Ø¨Ø·Ø§Ù‚Ø§Øª */
function refreshCards() {
  if (!cardsRoot) return;
  cardsRoot.innerHTML = '';
  bodies.forEach((b,i)=>{
    const card = document.createElement('div');
    card.className = 'card' + (b.selected ? ' selected' : '');
    const km = isFinite(b.radius) ? (b.radius/1000).toFixed(0) : 'â€”';
    card.innerHTML = `
      <h4>${b.name}
        <span class="badgeSmall" style="background:${b.color};color:#000;border-color:rgba(0,0,0,0.2)">${km} km</span>
      </h4>
      <div class="meta">
        <span>ÙƒØªÙ„Ø©:</span> <span>${b.mass.toExponential(2)} kg</span>
        <span>Ù…ÙˆÙ‚Ø¹:</span> <span>(${(b.x/1e9).toFixed(1)}, ${(b.y/1e9).toFixed(1)}, ${(b.z/1e9).toFixed(1)}) Gm</span>
        <span>Ø³Ø±Ø¹Ø©:</span> <span>${mag(b.vx,b.vy,b.vz).toFixed(1)} m/s</span>
      </div>
      ${b.precession ? `
      <div class="meta" style="margin-top:4px">
        <span>Ù…Ø±Ø¬Ø¹:</span> <span>${b.centerBody}</span>
        <span>a:</span> <span>${isFinite(b.a)?(b.a/1e9).toFixed(1):'â€”'} Gm</span>
        <span>e:</span> <span>${isFinite(b.e)?b.e.toFixed(4):'â€”'}</span>
        <span style="color:var(--accent)">Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªÙ‚Ø¯Ù…:</span> <span style="color:var(--accent)">${b.precession.toFixed(2)} "/Ù‚Ø±Ù†</span>
      </div>`: '' }
      <div class="rowBtns">
  <button onclick="selectBody(${i})">${b.selected ? 'âœ“ Ù…Ø­Ø¯Ø¯' : 'ØªØ­Ø¯ÙŠØ¯'}</button>
  <button onclick="toggleTrackGroup(${i})" style="background:${trackState.group.has(i)?'#2b9348':'#1f2a3d'}">
    ğŸ¯ ${trackState.group.has(i)?'Ø¶Ù…Ù† Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©':'Ø£Ø¶ÙÙ Ù„Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©'}
  </button>
  <button onclick="removeBody(${i})" style="background:var(--bad)">Ø­Ø°Ù</button>
</div>

    `;
    cardsRoot.appendChild(card);
  });
}
function selectBody(index){ bodies.forEach((b,i)=>b.selected=(i===index)); refreshCards(); }
function removeBody(index){ bodies.splice(index,1); refreshCards(); refreshTrackList(); }
function toggleTrackGroup(i){
  if (trackState.group.has(i)) trackState.group.delete(i);
  else trackState.group.add(i);
  refreshCards();
}

/* Ù…Ø±ÙƒØ² Ø§Ù„ÙƒØªÙ„Ø© */
function getCenterOfMass(){
  if (!bodies.length) return {x:0,y:0,z:0};
  let m=0,x=0,y=0,z=0;
  for (const b of bodies){ m+=b.mass; x+=b.mass*b.x; y+=b.mass*b.y; z+=b.mass*b.z; }
  return m>0?{x:x/m,y:y/m,z:z/m}:{x:0,y:0,z:0};
}
function getGroupCenter(){
  if (trackState.group.size === 0) return null;
  let M=0, x=0, y=0, z=0;
  for (const i of trackState.group){
    const b = bodies[i]; if (!b) continue;
    const m = Math.max(1, b.mass); // ØªØ±Ø¬ÙŠØ­ Ø¨Ø§Ù„ÙƒØªÙ„Ø©
    M+=m; x+=m*b.x; y+=m*b.y; z+=m*b.z;
  }
  if (M===0) return null;
  return {x:x/M, y:y/M, z:z/M};
}

function getTrackOffset(){
  switch(trackState.mode){
    case 'body': {
      const i = trackState.bodyIndex;
      const b = (i>=0 && bodies[i]) ? bodies[i] : null;
      return b ? {x:b.x, y:b.y, z:b.z} : {x:0,y:0,z:0};
    }
    case 'group': {
      const g = getGroupCenter();
      return g ? g : {x:0,y:0,z:0};
    }
    case 'cm': return getCenterOfMass();
    case 'free':
    default: return {x:0,y:0,z:0};
  }
}

function heaviestIndex(){
  if (!bodies.length) return -1;
  let hi = 0;
  for (let i=1;i<bodies.length;i++) if (bodies[i].mass > bodies[hi].mass) hi = i;
  return hi;
}

function getTotalMomentum(){
  let Px=0, Py=0, Pz=0;
  for (const b of bodies){ Px += b.mass*b.vx; Py += b.mass*b.vy; Pz += b.mass*b.vz; }
  return {Px,Py,Pz};
}

/*  Ø§Ù„Ø¥Ø·Ø§Ø± Ø§Ù„Ø¨Ø§Ø±ÙŠ-Ø§Ù„Ù…Ø±ÙƒØ²ÙŠ: Ù†Ø·Ø±Ø­ Ù…Ø±ÙƒØ² Ø§Ù„ÙƒØªÙ„Ø© ÙˆØ³Ø±Ø¹ØªÙ‡ Ù…Ù† Ø§Ù„Ø¬Ù…ÙŠØ¹ */
function reframeToBarycentric(){
  if (!bodies.length) return;
  let M=0, cx=0, cy=0, cz=0, cvx=0, cvy=0, cvz=0;
  for (const b of bodies){
    M += b.mass;
    cx += b.mass*b.x; cy += b.mass*b.y; cz += b.mass*b.z;
    cvx += b.mass*b.vx; cvy += b.mass*b.vy; cvz += b.mass*b.vz;
  }
  if (M <= 0) return;
  cx/=M; cy/=M; cz/=M; cvx/=M; cvy/=M; cvz/=M;
  for (const b of bodies){
    b.x -= cx; b.y -= cy; b.z -= cz;
    b.vx -= cvx; b.vy -= cvy; b.vz -= cvz;
  }
  refreshCards(); refreshTrackList(); updateCamera(); // Ø´ÙƒÙ„Ù‹Ø§ ÙÙ‚Ø·
}

/* ØªØ«Ø¨ÙŠØª Ø§Ù„Ø£ØµÙ„ Ø¹Ù†Ø¯ Ø§Ù„Ø£Ø«Ù‚Ù„: Ù†Ø·Ø±Ø­ Ù…ÙˆØ¶Ø¹/Ø³Ø±Ø¹Ø© Ø§Ù„Ø£Ø«Ù‚Ù„ Ù…Ù† Ø§Ù„Ø¬Ù…ÙŠØ¹ */
function anchorToHeaviest(){
  const hi = heaviestIndex();
  if (hi < 0) return;
  const H = bodies[hi];
  for (const b of bodies){
    b.x -= H.x; b.y -= H.y; b.z -= H.z;
    b.vx -= H.vx; b.vy -= H.vy; b.vz -= H.vz;
  }
  refreshCards(); refreshTrackList(); updateCamera();
}

/* ØªÙˆÙ„ÙŠÙ Ø³Ø±Ø¹Ø§Øª Ø¯Ø§Ø¦Ø±ÙŠØ© ØªÙ‚Ø±ÙŠØ¨ÙŠØ© Ø­ÙˆÙ„ Ø§Ù„Ø£Ø«Ù‚Ù„ (Ø§Ø®ØªÙŠØ§Ø±ÙŠ): v = sqrt(GM/r) Ø¨Ø§ØªØ¬Ø§Ù‡ Ø¹Ù…ÙˆØ¯ÙŠ Ø¹Ù„Ù‰ r */
function retuneCircularAroundHeaviest(){
  const hi = heaviestIndex();
  if (hi < 0 || bodies.length < 2) return;
  const H = bodies[hi];
  for (let i=0;i<bodies.length;i++){
    if (i === hi) continue;
    const b = bodies[i];
    // Ù…ÙˆØ¶Ø¹ ÙˆØ³Ø±Ø¹Ø© Ù†Ø³Ø¨Ø©Ù‹ Ù„Ù„Ø£Ø«Ù‚Ù„
    const rx = b.x - H.x, ry = b.y - H.y, rz = b.z - H.z;
    const r = Math.hypot(rx, ry, rz);
    if (r < 1) continue;
    const v_circ = Math.sqrt(G * H.mass / r);

    // Ù†Ø®ØªØ§Ø± Ø§ØªØ¬Ø§Ù‡ Ø³Ø±Ø¹Ø© Ø¹Ù…ÙˆØ¯ÙŠ Ø¹Ù„Ù‰ r Ù‚Ø¯Ø± Ø§Ù„Ø¥Ù…ÙƒØ§Ù† Ø­Ø³Ø¨ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø­Ø§Ù„ÙŠ:
    // Ù„Ùˆ ÙƒØ§Ù† Ù„Ù„Ø¨ÙØ±Ø¬ Ø³Ø±Ø¹Ø© Ø­Ø§Ù„ÙŠØ©ØŒ Ù†Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø±ÙƒØ¨Ø© Ø§Ù„Ø¹Ù…ÙˆØ¯ÙŠØ© Ø¹Ù„Ù‰ r Ù„Ø­ÙØ¸ Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù…Ø¯Ø§Ø±
    let vx = b.vx - H.vx, vy = b.vy - H.vy, vz = b.vz - H.vz;
    // Ù…Ø±ÙƒØ¨Ø© v Ø§Ù„Ø¹Ù…ÙˆØ¯ÙŠØ© Ø¹Ù„Ù‰ r: v_perp = v - (vÂ·rÌ‚) rÌ‚
    const rhatx = rx/r, rhaty = ry/r, rhatz = rz/r;
    const vdotr = vx*rhatx + vy*rhaty + vz*rhatz;
    let vpx = vx - vdotr*rhatx, vpy = vy - vdotr*rhaty, vpz = vz - vdotr*rhatz;
    let vp = Math.hypot(vpx,vpy,vpz);

    if (vp < 1e-9){
      // Ù„Ùˆ Ø§Ù„Ø³Ø±Ø¹Ø© ØªÙ‚Ø±ÙŠØ¨Ø§ ØµÙØ±ØŒ Ù†Ø®ØªØ§Ø± Ø§ØªØ¬Ø§Ù‡Ù‹Ø§ Ø«Ø§Ø¨ØªÙ‹Ø§ Ø¹Ù…ÙˆØ¯ÙŠÙ‹Ø§ Ø¹Ù„Ù‰ r (Ù…Ø«Ù„ zÃ—r)
      // n = k Ã— r
      const nx = -ry, ny = rx, nz = 0;
      const nlen = Math.hypot(nx,ny,nz) || 1;
      vpx = nx/nlen; vpy = ny/nlen; vpz = nz/nlen; vp = 1;
    } else {
      // Ø·Ø¨Ù‘Ø¹ Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø­Ø§Ù„ÙŠ Ø§Ù„Ø¹Ù…ÙˆØ¯ÙŠ
      vpx /= vp; vpy /= vp; vpz /= vp;
    }
    // Ø§Ø¶Ø¨Ø· Ù…Ù‚Ø¯Ø§Ø± Ø§Ù„Ø³Ø±Ø¹Ø© Ù„Ù„Ø¯Ø§Ø¦Ø±ÙŠØ©
    vx = vpx * v_circ; vy = vpy * v_circ; vz = vpz * v_circ;

    // Ø§Ø±Ø¬Ø¹ Ø¥Ù„Ù‰ Ø§Ù„Ø¥Ø·Ø§Ø± Ø§Ù„Ø¹Ø§Ù… (Ù†Ø¬Ø¹Ù„ Ø§Ù„Ø£Ø«Ù‚Ù„ Ø³Ø§ÙƒÙ† Ø¨Ø¹Ø¯ Ø°Ù„Ùƒ Ø¨Ø²Ø±Ù‘ Ø§Ù„ØªØ«Ø¨ÙŠØª Ø¥Ù† Ø±ØºØ¨Øª)
    b.vx = H.vx + vx; b.vy = H.vy + vy; b.vz = H.vz + vz;
  }
  refreshCards();
}


/* Ø´Ø¨ÙƒØ© + Ù…Ø­ÙˆØ± XYZ */
function drawGrid(ctx){
  if (!state.showGrid) return;

  // Ù…Ø±ÙƒØ² Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ (Ø­Ø³Ø¨ ÙˆØ¶Ø¹ Ø§Ù„ØªØªØ¨Ù‘Ø¹)
  const center = getTrackOffset();

  // Ø­Ø¬Ù… Ø§Ù„Ø®Ù„ÙŠØ© ÙŠØªÙƒÙŠÙ‘Ù Ù…Ø¹ Ø§Ù„Ù…Ø³Ø§ÙØ© (ÙƒÙ„ 10^k ØªÙ‚Ø±ÙŠØ¨Ù‹Ø§)
  const base = cam.dist * 0.5;
  const gridSize = Math.pow(10, Math.floor(Math.log10(Math.max(1, base))));
  const fine = gridSize / 5; // Ø®Ø·ÙˆØ· Ø«Ø§Ù†ÙˆÙŠØ©
  const worldPerPixel = (cam.dist / Math.max(1, cam.scale)); // ØªÙ‚Ø¯ÙŠØ± ØªÙ‚Ø±ÙŠØ¨ÙŠ

  // Ù…Ø¯Ù‰ Ø§Ù„Ø±Ø³Ù… Ø¨Ø§Ù„Ø¨ÙŠÙƒØ³Ù„ â†’ Ø­ÙˆÙ‘Ù„Ù‡ Ù„Ø¹Ø§Ù„Ù…
  const w = view.width, h = view.height;
  const spanX = worldPerPixel * (w / cam.dist);
  const spanY = worldPerPixel * (h / cam.dist);

  // Ø§Ù†Ø²ÙŠØ§Ø­ Ø¨Ø­ÙŠØ« ØªØ¨Ù‚Ù‰ Ø®Ø·ÙˆØ· Ø§Ù„Ø´Ø¨ÙƒØ© "Ù…Ù‚Ù†Ù‘Ø¹Ø©" ØªØ­Øª Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
  // Ù†Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ù‚Ø³Ù…Ø© Ù„Ø¥Ø²Ø§Ø­Ø© Ø§Ù„Ø´Ø¨ÙƒØ© Ù…Ø¹ ØªØ­Ø±Ù‘Ùƒ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
  const offX = ((center.x % gridSize) + gridSize) % gridSize;
  const offY = ((center.y % gridSize) + gridSize) % gridSize;
  const offXf = ((center.x % fine) + fine) % fine;
  const offYf = ((center.y % fine) + fine) % fine;

  // Ø¹Ø¯Ø¯ Ø§Ù„Ø®Ø·ÙˆØ· Ø§Ù„ÙƒØ§ÙÙŠ Ù„ØªØºØ·ÙŠØ© Ø§Ù„Ø´Ø§Ø´Ø©
  const N = 50;

  // Ø®Ø·ÙˆØ· Ø«Ø§Ù†ÙˆÙŠØ©
  ctx.lineWidth = 1;
  ctx.strokeStyle = 'rgba(160, 180, 210, .10)';
  for (let i=-N;i<=N;i++){
    const xw = center.x - offX + i*fine;
    const yw = center.y - offY + i*fine;

    const p1 = project(xw, center.y - N*fine, center.z);
    const p2 = project(xw, center.y + N*fine, center.z);
    if (p1 && p2){ ctx.beginPath(); ctx.moveTo(p1[0],p1[1]); ctx.lineTo(p2[0],p2[1]); ctx.stroke(); }

    const p3 = project(center.x - N*fine, yw, center.z);
    const p4 = project(center.x + N*fine, yw, center.z);
    if (p3 && p4){ ctx.beginPath(); ctx.moveTo(p3[0],p3[1]); ctx.lineTo(p4[0],p4[1]); ctx.stroke(); }
  }

  // Ø®Ø·ÙˆØ· Ø±Ø¦ÙŠØ³ÙŠØ©
  ctx.lineWidth = 1.2;
  ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid') || '#1f2a3d';
  for (let i=-N;i<=N;i++){
    const xw = center.x - offX + i*gridSize;
    const yw = center.y - offY + i*gridSize;

    const p1 = project(xw, center.y - N*gridSize, center.z);
    const p2 = project(xw, center.y + N*gridSize, center.z);
    if (p1 && p2){ ctx.beginPath(); ctx.moveTo(p1[0],p1[1]); ctx.lineTo(p2[0],p2[1]); ctx.stroke(); }

    const p3 = project(center.x - N*gridSize, yw, center.z);
    const p4 = project(center.x + N*gridSize, yw, center.z);
    if (p3 && p4){ ctx.beginPath(); ctx.moveTo(p3[0],p3[1]); ctx.lineTo(p4[0],p4[1]); ctx.stroke(); }
  }
}

function drawAxes(){
  const c = getCenterOfMass();
  const L = cam.dist * 0.4;
  const axes = [
    {p:[c.x, c.y, c.z], q:[c.x+L, c.y, c.z], col:'#ff6666', label:'X'},
    {p:[c.x, c.y, c.z], q:[c.x, c.y+L, c.z], col:'#66ff66', label:'Y'},
    {p:[c.x, c.y, c.z], q:[c.x, c.y, c.z+L], col:'#66ccff', label:'Z'},
  ];
  ctx.lineWidth = 2;
  for (const a of axes){
    const P = project(...a.p), Q = project(...a.q);
    if (P && Q){
      ctx.strokeStyle = a.col; ctx.beginPath(); ctx.moveTo(P[0],P[1]); ctx.lineTo(Q[0],Q[1]); ctx.stroke();
    }
  }
}

/* Ø±Ø³Ù… */
function draw(){
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg') || '#000';
  ctx.fillRect(0,0,view.width,view.height);
  drawGrid(ctx); drawAxes();

  const trkSel = Number(q('track').value);
  const trackBody = isFinite(trkSel) && trkSel>=0 ? bodies[trkSel] : null;
  const trackOffset = getTrackOffset() ? {x:trackBody.x,y:trackBody.y,z:trackBody.z} : {x:0,y:0,z:0};

  const sorted = bodies.map((b,i)=>({...b,__i:i}))
    .sort((A,B)=>{
      const pa = project(A.x - trackOffset.x, A.y-trackOffset.y, A.z-trackOffset.z);
      const pb = project(B.x - trackOffset.x, B.y-trackOffset.y, B.z-trackOffset.z);
      return ((pb?.[2]||0) - (pa?.[2]||0));
    });

  for (const b of sorted){
    const pos = project(b.x - trackOffset.x, b.y - trackOffset.y, b.z - trackOffset.z);
    if (!pos) continue;
    const [X,Y,z2,scale] = pos;
    const rDyn = Math.max(2, Math.cbrt(Math.max(1e0, b.mass)/1e20) * (cam.dist/Math.max(1,z2)) * 0.0005);
    const radius = isFinite(rDyn)? rDyn : 2;

    // Trail
    if (state.trails && b.trail && b.trail.length > 1){
      ctx.beginPath(); ctx.strokeStyle = b.color; ctx.lineWidth = 1;
      let first = true;
      for (const p of b.trail){
        const t = project(p.x - trackOffset.x, p.y - trackOffset.y, p.z - trackOffset.z);
        if (!t) continue;
        if (first){ ctx.moveTo(t[0],t[1]); first=false; } else ctx.lineTo(t[0],t[1]);
      }
      ctx.stroke();
    }

    // Body
    ctx.fillStyle = b.color; ctx.beginPath(); ctx.arc(X,Y,radius,0,Math.PI*2);
    if (isFinite(X) && isFinite(Y) && isFinite(radius)) ctx.fill();
    if (b.selected){ ctx.strokeStyle = 'var(--accent)'; ctx.lineWidth = 2; ctx.stroke(); }
  }
}

/* HUD + Ø±Ø³Ù… Ø§Ù„Ù…Ø®Ø·Ø· */
let lastEnergy = 0, energyHistory = [];
function updateStats(){
  const { E, KE, PE, Lz } = energyAndAngMom();
  if (lastEnergy === 0) lastEnergy = E;
  const dE = Math.abs((E - lastEnergy) / lastEnergy) * 1e2 || 0;

  hudStats.innerHTML = `
    <span>Ø§Ù„ÙˆÙ‚Øª (Ø³):</span> <span>${(time/3600).toFixed(1)}</span>
    <span>Ø§Ù„Ø·Ø§Ù‚Ø© Ø§Ù„ÙƒÙ„ÙŠØ©:</span> <span>${E.toExponential(4)} J</span>
    <span>Ø§Ù„ØªØºÙŠØ± (Ùª):</span> <span style="color:var(--${dE < 0.01 ? 'good' : dE < 0.1 ? 'warn' : 'bad'})">${dE.toFixed(4)} %</span>
    <span>Ø§Ù„Ø²Ø®Ù… Ø§Ù„Ø²Ø§ÙˆÙŠ Z:</span> <span>${Lz.toExponential(4)}</span>
    <span>dt Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…:</span> <span>${currentDt.toExponential(2)} Ø«</span>
  `;
  energyHistory.push(dE); if (energyHistory.length>120) energyHistory.shift();

  cctx.clearRect(0,0,chart.width,chart.height);
  const maxErr = Math.max(0.001, ...energyHistory);
  const scaleY = chart.height / maxErr;
  cctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent') || '#59c1ff';
  cctx.lineWidth = 1.5;
  cctx.beginPath();
  const startX = Math.max(0, chart.width - energyHistory.length);
  cctx.moveTo(startX, chart.height - energyHistory[0] * scaleY);
  energyHistory.forEach((v,i)=>cctx.lineTo(startX+i, chart.height - v*scaleY));
  cctx.stroke();
}

/* Ø­Ù„Ù‚Ø© Ø§Ù„ØªØ­Ø¯ÙŠØ« */
function updateSimulation(){
  const t0 = performance.now();
  let steps = 0;
  while (running && (performance.now() - t0) < 10){
    const dt = +q('dt').value || 1;
    integrateAdaptive(dt);
    handleCollisions();
    bodies.forEach(b=>{
      b.trail.push({x:b.x,y:b.y,z:b.z});
      if (b.trail.length>600) b.trail.shift();
    });
    steps++;
  }
  if (steps>0) updateStats();
}
function loop(){ if (running) updateSimulation(); draw(); requestAnimationFrame(loop); }

/* Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…Ø´Ø§Ù‡Ø¯ */
const initialBodies = [
  { name:"Sun", mass:1.989e30, x:0,y:0,z:0, vx:0,vy:0,vz:0, radius:696340e3, color:'#f7f43e' },
  { name:"Mercury", mass:3.302e23, x:46.0e9,y:0,z:0, vx:0,vy:58980,vz:0, radius:2440e3, color:'#bdbdbd' },
  { name:"Earth", mass:5.972e24, x:1.5e11,y:0,z:0, vx:0,vy:29780,vz:0, radius:6371e3, color:'#59c1ff' }
];
function loadPreset(name){
  time=0; bodies=[]; energyHistory=[]; lastEnergy=0;
  let presetBodies=[];
  switch(name){
    case 'solar': presetBodies = initialBodies; break;
    case 'binary':
      presetBodies = [
        { name:"Star A", mass:2e30, x:-1e11,y:0,z:0, vx:0,vy:-15000,vz:0, radius:7e8, color:'#f7cc60' },
        { name:"Star B", mass:1e30, x: 2e11,y:0,z:0, vx:0,vy: 30000,vz:0, radius:5e8, color:'#c39df3' }
      ]; break;
    case 'three':
      presetBodies = [
        { name:"Body 1", mass:1e27, x:1e10,y:0,z:0, vx:0,vy:0,vz:0, radius:1e7, color:randColor() },
        { name:"Body 2", mass:1e27, x:-1e10,y:0,z:0, vx:0,vy:0,vz:0, radius:1e7, color:randColor() },
        { name:"Body 3", mass:1e27, x:0,y:1e10,z:0, vx:0,vy:0,vz:0, radius:1e7, color:randColor() }
      ]; break;
    case 'bhStar':
      presetBodies = [
        { name:"Black Hole", mass:1e32, x:0,y:0,z:0, vx:0,vy:0,vz:0, radius:10e3, color:'#2b2b2b' },
        { name:"Star", mass:2e30, x:5e11,y:0,z:0, vx:0,vy:20000,vz:0, radius:7e8, color:'#ff7b72' }
      ];
      q('enablePN').checked = true; state.pn = true;
      break;
    case 'random':
      for (let i=0;i<10;i++){
        presetBodies.push({
          name:"R-Body "+(i+1),
          mass: 1e25 + Math.random()*1e26,
          x:(Math.random()-0.5)*5e11, y:(Math.random()-0.5)*5e11, z:(Math.random()-0.5)*5e11,
          vx:(Math.random()-0.5)*10000, vy:(Math.random()-0.5)*10000, vz:(Math.random()-0.5)*10000,
          radius: 1e7 + Math.random()*5e7, color:randColor()
        });
      }
      trackState.group.clear(); // ØªÙØ±ÙŠØº Ù…Ø¬Ù…ÙˆØ¹Ø© Ø§Ù„ØªØªØ¨Ù‘Ø¹ Ø¹Ù†Ø¯ ØªØºÙŠÙŠØ± Ø§Ù„Ù…Ø´Ù‡Ø¯

      break;
  }
  presetBodies.forEach(b=>{ b.trail=[]; bodies.push(b); });
  if (q('enablePN')) q('enablePN').checked = state.pn;
  refreshCards(); refreshTrackList(); updateCamera(); reorbit();
  q('btnLoadPreset').disabled = false;
  // ÙÙŠ Ù†Ù‡Ø§ÙŠØ© loadPreset:
if (q('anchorHeavy')?.checked) anchorToHeaviest(); else reframeToBarycentric();

}

/* ØªØªØ¨Ø¹ ÙˆØ¥Ø¹Ø§Ø¯Ø© Ø­Ø³Ø§Ø¨ */
function refreshTrackList(){
  const select = q('track');
  const prev = Number(select.value);
  select.innerHTML = '<option value="-1">Ø§Ù„Ù…Ø±Ø¬Ø­ (CM)</option>';
  bodies.forEach((b,i)=>{ const o=document.createElement('option'); o.value=i; o.textContent=b.name; select.appendChild(o); });
  select.value = (!isFinite(prev) || prev>=bodies.length) ? '-1' : String(prev);
  trackState.bodyIndex = Number(select.value);
}
q('track').onchange = e => { trackState.bodyIndex = Number(e.target.value); };

function reorbit(){ bodies.forEach((b,i)=>computeRelativisticOrbitForBody(i)); refreshCards(); }

/* ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø£Ø­Ø¯Ø§Ø« */
function bindUI(){
  q('btnPlay').onclick = () => { running = !running; q('btnPlay').textContent = running ? 'â¸ Ø¥ÙŠÙ‚Ø§Ù' : 'â–¶ ØªØ´ØºÙŠÙ„'; };
  q('btnStep').onclick = () => { if (!running){ integrateAdaptive(+q('dt').value || 1); handleCollisions(); updateStats(); } };
  q('btnReset').onclick = () => loadPreset(q('preset').value);

  q('speedMul').onchange = e => state.speedMul = Math.max(0.1, +e.target.value || 1);
  q('dt').onchange = e => state.dt = +e.target.value || 1;
  q('adaptive').onchange = e => state.adaptive = e.target.checked;
  q('enablePN').onchange = e => { state.pn = e.target.checked; if (e.target.checked) reorbit(); };
  q('collisionMode').onchange = e => state.collision = e.target.value;

  q('preset').onchange = () => { q('btnLoadPreset').disabled = false; };
  q('btnLoadPreset').onclick = () => { loadPreset(q('preset').value); };

  q('showTrails').onchange = e => state.trails = e.target.checked;
  q('showGrid').onchange = e => state.showGrid = e.target.checked;
  q('btnReorbit').onclick = reorbit;
  q('btnTrackRecalc').onclick = () => { reorbit(); setTimeout(reorbit, 40000 / Math.max(0.1,state.speedMul)); };

  q('trackMode').onchange = e => { trackState.mode = e.target.value; };

  q('btnAdd').onclick = () => {
  const m = +q('bMass').value || 1;
  const newBody = {
    name: q('bName').value || "Body",
    mass: m,
    x:+q('bX').value||0, y:+q('bY').value||0, z:+q('bZ').value||0,
    vx:+q('bVX').value||0, vy:+q('bVY').value||0, vz:+q('bVZ').value||0,
    radius: Math.max(1000, Math.cbrt(Math.max(1,m)/1e20) * 1e7),
    color: randColor(),
    trail: []
  };
  bodies.push(newBody);

  // Ù„Ùˆ Ø§Ù„Ø¬Ø±Ù… Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ø£Ø«Ù‚Ù„ Ù…Ù† Ù…Ø¬Ù…ÙˆØ¹ Ø§Ù„Ø¨Ø§Ù‚ÙŠ Ã— 0.5 Ø£Ùˆ Ø£Ø«Ù‚Ù„ Ù…Ù† Ø§Ù„Ø£Ø«Ù‚Ù„ Ø§Ù„Ø³Ø§Ø¨Ù‚ â†’ Ø£Ø¹ÙØ¯ Ø§Ù„ØªÙ…ÙˆØ¶Ø¹
  const totalOthers = bodies.slice(0,-1).reduce((s,b)=>s+b.mass,0);
  const heavyChanged = (m > totalOthers*0.5) || (heaviestIndex() === bodies.length-1);
  if (q('anchorHeavy').checked && heavyChanged){
    // (1) Ø·ÙˆÙ‘Ø± Ø§Ù„Ø¥Ø·Ø§Ø± Ù…Ø±Ø¬Ø¹ÙŠÙ‹Ø§ Ù„Ù„Ø£Ø«Ù‚Ù„
    anchorToHeaviest();
    // (2) Ø§Ø®ØªÙŠØ§Ø±ÙŠØ©: Ù„Ùˆ ØªØ­Ø¨ Ø¶Ø¨Ø· Ø³Ø±Ø¹Ø§Øª Ù„Ù„Ø£Ø¬Ø±Ø§Ù… Ø§Ù„Ø£Ø®Ø±Ù‰ Ù…Ø¨Ø§Ø´Ø±Ø©Ù‹:
    // retuneCircularAroundHeaviest();
  } else {
    // Ø§ÙØªØ±Ø§Ø¶ÙŠÙ‹Ø§: Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„ Ø®Ù„Ù‘ÙŠ Ø§Ù„Ø¥Ø·Ø§Ø± Ø¨Ø§Ø±ÙŠ-Ù…Ø±ÙƒØ²ÙŠ
    reframeToBarycentric();
  }

  refreshCards();
  refreshTrackList();
  reorbit();
};

  q('btnClear').onclick = () => { bodies=[]; refreshCards(); refreshTrackList(); };

  q('btnCSV').onclick = () => {
    let csv = "Time(s),Body Name,x,y,z,vx,vy,vz\n";
    bodies.forEach(b=>{ csv += `${time},${b.name},${b.x},${b.y},${b.z},${b.vx},${b.vy},${b.vz}\n`; });
    const blob = new Blob([csv], { type:'text/csv' });
    const a = document.createElement('a');
    a.download = 'nbody_sim_' + new Date().toISOString().replace(/[:.]/g,'-') + '.csv';
    a.href = URL.createObjectURL(blob); a.click(); URL.revokeObjectURL(a.href);
  };
  q('btnBary').onclick = () => { reframeToBarycentric(); reorbit(); };
q('btnAnchorHeavy').onclick = () => { anchorToHeaviest(); reorbit(); };
q('btnRetune').onclick = () => { retuneCircularAroundHeaviest(); if (q('anchorHeavy').checked) anchorToHeaviest(); reorbit(); };

  /* Ø²Ø± Ø§Ù„ØªØ³Ø®ÙŠÙ† */
  q('btnWarmup').onclick = () => warmup(200, 0.2);
}

/* ØªØ³Ø®ÙŠÙ† Ø§Ù„Ù†Ø¸Ø§Ù… ÙƒÙ…Ø§ Ø·Ù„Ø¨Øª */
function warmup(steps=200, dtFactor=0.2){
  const base = state.dt;
  const oldAdaptive = state.adaptive;
  state.adaptive = false;
  for (let k=0;k<steps;k++){
    rk4Step(base * dtFactor, state.pn);
    time += base * dtFactor;
    bodies.forEach(b=>{
      b.trail.push({x:b.x,y:b.y,z:b.z});
      if (b.trail.length>600) b.trail.shift();
    });
  }
  state.adaptive = oldAdaptive;
  updateStats();
}

/* Ø¥Ø¹Ø§Ø¯Ø© Ø­Ø³Ø§Ø¨ Ø¯ÙˆØ±ÙŠ */
let autoReorbitInterval;
function startAutoReorbit(){
  clearInterval(autoReorbitInterval);
  autoReorbitInterval = setInterval(()=>{ if (running && q('autoReorbit').checked) reorbit(); }, 30000);
}

/* ØªØ´ØºÙŠÙ„ Ø£ÙˆÙ„ÙŠ */
resize(); updateCamera();
loadPreset('solar');
bindUI();
startAutoReorbit();
requestAnimationFrame(loop);
</script>
</body>
</html>
